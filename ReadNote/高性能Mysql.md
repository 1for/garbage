# 第三章 架构优化和索引
## 选择优化的数据类型的原则
- 更小通常更好
- 简单就好（使用Mysql内建类型保存日期和时间，使用整数来保存IP）
- 尽量避免NULL

> Mysql可以定义整数类型的宽度，INT（11）。这对于大多数应用程序是没有意义的，它不会限制值的范围，只是规定了Mysql的交互工具用来显示字符的个数。对于存储和计算，INT（1）和INT（20）是一样的。

> `COUNT(*)`是COUNT的一种特例，它不会把通配符星号展开成所有的列，而是忽略所有的列并统计行数。

## 语句执行性能分析参数
	Query_time 执行的时间
	Lock_time 等待锁的时间
	Rows_sent 查询返回的行数
	Rows_examined 查询检查的行数
	QC_Hit 查询是否从查询缓存中取值
	Full_scan 是否进行了全表扫描
	Full_join 是否进行了没使用索引的联接
	Tmp_table 是否使用了临时表
	Disk_tmp_table 是否使用了磁盘上的临时表
	Filesort 是否使用了文件排序
	Disk_filesort 是否在磁盘上进行文件排序
	Merge_passes 排序的时候执行了多少次排序合并
	InnoDB_IO_r_ops 进行了多少此页面读取操作
	InnoDB_IO_r_bytes 读取了多少字节
	InnoDB_IO_r_wait 读取数据花费的时间
	InnoDB_rec_lock_wait 等待行级锁的时间
	InnoDB_queue_wait 等待进入InnoDB核心的时间
	InnoDB_pages_distinct 查询访问了多少唯一的InnoDB表

> 索引通常对SELECT查询有帮助，但是会减缓INSERT和UPDATE查询

## 线程和连接的统计信息

	+------------------------------+---------+ 
	| Variable_name                | Describe| 
	+------------------------------+---------+ 
	| connections				   | 		 |
	+------------------------------+---------+ 

## 查询缓存相关参数

	mysql> SHOW VARIABLES LIKE ’%query_cache%’; 
	+------------------------------+---------+ 
	| Variable_name                | Value   | 
	+------------------------------+---------+ 
	| have_query_cache             | YES     | --查询缓存是否可用 
	| query_cache_limit            | 1048576 | --可缓存具体查询结果的最大值 
	| query_cache_min_res_unit     | 4096    |  
	| query_cache_size             | 599040  | --查询缓存的大小 
	| query_cache_type             | ON      | --阻止或是支持查询缓存 
	| query_cache_wlock_invalidate | OFF     |  
	+------------------------------+---------+  

## MyISAM存储引擎的特征：

	- 所有数据值先存储低字节。这使得数据机和操作系统分离。二进制轻便性的唯一要求是机器使用补码（如最近20年的机器有的一样）和IEEE浮点格式（在主流机器中也完全是主导的）。唯一不支持二进制兼容性的机器是嵌入式系统。这些系统有时使用特殊的处理器。先存储数据低字节并不严重地影响速度；数据行中的字节一般是未联合的，从一个方向读未联合的字节并不比从反向读更占用更多的资源。服务器上的获取列值的代码与其它代码相比并不显得时间紧。
	- 
	- 大文件（达63位文件长度）在支持大文件的文件系统和操作系统上被支持。
	- 
	- 当把删除和更新及插入混合的时候，动态尺寸的行更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块来自动完成。
	- 
	- 每个MyISAM表最大索引数是64。 这可以通过重新编译来改变。每个索引最大的列数是16个。
	- 
	- 最大的键长度是1000字节。这也可以通过编译来改变。对于键长度超过250字节的情况，一个超过1024字节的的键块被用上。
	- 
	- BLOB和TEXT列可以被索引。
	- 
	- NULL值被允许在索引的列中。这个占每个键的0-1个字节。
	- 
	- 所有数字键值以高字节为先被存储以允许一个更高地索引压缩。
	- 
	- 当记录以排好序的顺序插入（就像你使用一个AUTO_INCREMENT列之时），索引树被劈开以便高节点仅包含一个键。这改善了索引树的空间利用率。
	- 
	- 每表一个AUTO_INCREMEN列的内部处理。MyISAM为INSERT和UPDATE操作自动更新这一列。这使得AUTO_INCREMENT列更快（至少10%）。在序列顶的值被删除之后就不能再利用。（当AUTO_INCREMENT列被定义为多列索引的最后一列，可以出现重使用从序列顶部删除的值的情况 ）。AUTO_INCREMENT值可用ALTER TABLE或myisamch来重置。
	- 
	- 如果数据文件中间的表没有自由块了，在其它线程从表读的同时，你可以INSERT新行到表中。（这被认识为并发操作 ）。自由块的出现是作为删除行的结果，或者是用比当前内容多的数据对动态长度行更新的结果。当所有自由块被用完（填满），未来的插入又变成并发。
	- 
	- 你可以把数据文件和索引文件放在不同目录，用DATA DIRECTORY和INDEX DIRECTORY选项CREATE TABLE以获得更高的速度，请参阅13.1.5节，“CREATE TABLE语法”。
	- 
	- 每个字符列可以又不同的字符集，请参阅第10章 ：“字符集支持”。
	- 
	- 在MyISAM索引文件里又一个标志，它表明表是否被正确关闭。如果用--myisam-recover选项启动mysqld，MyISAM表在打开得时候被自动检查，如果被表被不恰当地关闭，就修复表。
	- 
	- 如果你用--update-state选项运行myisamchk，它标注表为已检查。myisamchk --fast只检查那些没有这个标志的表。
	- 
	- myisamchk --analyze为部分键存储统计信息，也为整个键存储统计信息。
	- 
	- myisampack可以打包BLOB和VARCHAR列。

#工具介绍
## Mysql监控工具
- MoNyog

## Mysql日志分析工具
- mysqlsla

## SHOW STATUS
周期性的运行`show status`,并且和前一次的输出进行比较，可以用下面的命令进行
`mysqladmin extended -r -i 10`

+--------------------------------------------------+
| connect | 跟连接相关的统计信息 |
| Bytes_recevied和Bytes_sent | 和服务器之间来往的流量 |
| Com_* | 服务器正在执行的命令 |
| Created_* | 在查询执行期间创建的临时表和文件 |
| Handler_* | 存储引擎操作 |
| Select_* | 不同类型的联接执行计划 |
| Sort_* | 几种排序信息 |
| Key_* | MyISAM索引键缓冲区 |
| Open_* | 文件描述符 |
| Qcache_* | 查询缓存 |
| Innodb_* | Innodb特有的变量 |
| Last_query_cost | 最后一次查询时的开销 |
| Slave_* | 当服务器是从库是该项启用 |
| Uptime | 服务器正常运行时间 |
+--------------------------------------+

-innodb_max_dirty_pages_pct 进行冲刷行为，当修改过的页面占据缓冲值的百分比超过设置的值
-innodb_log_at_trx_commit 0把日志缓存写到日志文件中，并且没秒钟写一次，但是在事务提交的时候不进行任务动作（会丢失事务日志）； 1在事务提交的时候也会将缓存写到日志文件中

